# stack overflow attack

## background
stack overflow is an exploit where a user specifies a longer than expected buffer. which overflows the buffer up the stack, thus overwriting the return address to a shellcode in the specified buffer.

## caveat
modern operating systems and compiler have come a long way in making these exploits non-trivial. among the things that had to be disabled to demonstrate this basic exploit were,

- disabling ASLR
- disabling stack canary
- disabling stack protector
- disabling executable stack

## ASLR
ASLR is address space layout randomization, which means some addresses are randomized per process. this means addresses used in the shellcode cannot be hardcoded. breaking ASLR requires creative technique in obtaining address offset. alternatively, the shellcode could be more sophisticated in not relying on absolute addressing
- disable by setting /proc/sys/kernel/randomize_va_space to 0

## stack canary
stack canary is a sequence of special bytes added in the stack. the canary functions in two ways (afaik),
1. some special bytes terminate strings which cause functions like strcpy, gets, memcpy to stop before the full shellcode is copied,
2. the canary is checked before jumping to the new address, if the canary has been overwritten, the process terminates
- disable by -fno-stack-protector

## stack protector
endbr, endbr64 are new op codes on supported hardware which terminates the process if the first instruction after indirect call/jmp does not start with those instructions. this reduces the possible places shellcodes can jump to.
- disable by -mmanual-endbr

## executable stack
the stack space in modern compiler is marked as non-executable by default, this coupled with OS support causes the process to terminate when instruction pointer executes on stack space
- disable by -z execstack

## exploit
with all the above protections disabled, the stack overflow attack is demonstrated as below (see also [exploit.py](exploit.py) targeting [main.c](main.c))

the goal is to have the stacko executable call /bin/sh.

we overflow the buffer such that the return address points to the part of the shellcode that we want execution to start, in our case, "mov eax, 11". the shellcode we are using encodes the string "/bin/ls", and instructions to call execve on that string as argument, and 0 for argv and argc respectively. the gist of the shellcode is as follows,

```
/bin/sh           // careful to terminate string e.g., /bin/sh\0
mov eax, 11       // 11 is execve syscall
mov ebx, addr     // points to /bin/sh
mov ecx, 0        // 0 for argc, argv
mov edx, 0
int 0x80          // interrupt for syscall
pad               // pad shellcode till next instruction reaches return address
addr to shellcode // overwrite return address with address of "mov eax, 11"
```

