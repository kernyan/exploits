# stack overflow attack

## background
stack overflow is an exploit where a user specifies a longer than expected buffer. which overflows the buffer up the stack, thus overwriting the return address to a shellcode in the specified buffer.

## caveat
modern operating systems and compiler have come a long way in making these exploits non-trivial. among the things that had to be disabled to demonstrate this basic exploit are,

- disabling ASLR
- disabling stack canary
- disabling stack protector
- disabling executable stack

## ASLR
ASLR is address space layout randomization, which means some addresses are randomized per process. this makes addressing part of the shellcode cannot be hardcoded. breaking ASLR requires creative technique in obtaining address offset. alternatively, the shellcode would have to be more sophisticated in not relying on absolute addressing
- disable by setting /proc/sys/kernel/randomize_va_space to 0

## stack canary
stack canary is a sequence of special bytes after buffer/around function. the canary functions in two ways (afaik),
1. some special bytes terminate string which causes functions like strcpy, gets, memcpy to terminate early,
2. the canary is check before jumping to the new address, if canary has been overwritten, the process terminates
- disable by -fno-stack-protector

## stack protector
endbr, endbr64 are new op code on supported hardware which ensures that indirect call/jmp starts with these instructions. this reduces the possible places shellcode can jump to.
- disable by -mmanual-endbr

## executable stack
the stack space in modern compiler is by default marked as non-executable, this coupled with OS support causes the process to terminate when instruction pointer executes on stack space
- disable by -z execstack


## exploit
with the above protections all disabled, the stack overflow attack is demonstrated as below (also in [exploit.py](exploit.py) attacking [main.c](main.c))

we overflow the buffer such that the return address points to the part of the shellcode we want execution to start, in our case, "mov eax, 11". the shellcode we are using is to encode the string "/bin/ls", and instructions to call execve on that string as argument, and 0 for argv and argc respectively. the gist of the shellcode is as follows,

```
/bin/ls           // should be /bin//ls\0 to properly escape and terminate string
mov eax, 11       // 11 is execve syscall
mov ebx, addr     // points to /bin/ls
mov ecx, 0        // 0 for argc, argv
mov edx, 0
int 0x80          // interrupt for syscall
pad               // pad shellcode till next instruction reaches return address
addr to shellcode // overwrite return address with address of "mov eax, 11"
```

